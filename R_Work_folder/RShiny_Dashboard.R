#This allows to modify function
#trace("explore.data",edit=TRUE)


if(!require(DESeq2)){
  install.packages("BiocManager")
  BiocManager::install("DESeq2")
  library( "DESeq2" )
  library(ggplot2)
  library(apeglm)
  library(DESeq2)
}

if(!require(shiny)){
  install.packages("shiny")
  library(shiny)
}

if(!require(shinyWidgets)){
  install.packages("shinyWidgets")
  library(shinyWidgets)
} 

if(!require("DT")){
  install.packages("DT")
  library(DT)
}

if(!require("shinyjs")){
  install.packages("shinyjs")
  library(shinyjs)
}

if(!require("shinyDirectoryInput")){
  devtools::install_github('wleepang/shiny-directory-input')
  library(shinyDirectoryInput)
}

if(!require("shinydashboard")){
  install.packages("shinydashboard")
  library(shinydashboard)
}


options(shiny.maxRequestSize = 100*1024^2)
#############################################################################################################################################

#A function that is called to remove empty plots that are generated by R.
#A common error/bug in R is that when files are automatically saved as pdf's, R opens up an Rplot.pdf to allocate the space for that pdf
#However if we do not use that pdf (which is our case), it remains present, empty, and open. After around 50 open pdf files, R crashes.
#This function was created to delete these files every so often to prevent an accumulation of emtpy Rplots, thus preventing crashes
remove_Rplots <- function (Directory)
{
  Files_to_Remove <- list.files(Directory, recursive = TRUE, all.files = TRUE, pattern="Rplots")
  for (i in Files_to_Remove){
    unlink(paste(Directory,"\\",i,sep=""))
  }
}

#Checks the validity of an entered e-mail
isValidEmail <- function(x) 
{
  grepl("\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\>", as.character(x), 
        ignore.case=TRUE)
}

#Create the function for Deseq2
DESeq2_pre_processing <- function(File_1, File_2, variable_condition_1, variable_condition_2, do_MA_plot, do_Volcano_Plot)
{
  
  #Everything is in a try catch to ensure that the application does not crash in the event of an error
  #If an error does occur, it was desired that the application prints the error in a txt file and tells the user that an error has occured
  tryCatch({
    
    ###################################################################################################################################
    #File preperations for a file merge, i.e obtaining the necessary format for DESeq2 preprocessing
    ###################################################################################################################################
    File_1 <- read.csv(file = File_1,check.names=FALSE)
    File_2 <-read.csv(file = File_2,check.names=FALSE)
    
    #Filters out 0's and NA's, if a file is properly prepared, none of these should occur
    File_1<-File_1[complete.cases(File_1),]
    File_1<-File_1[!(File_1$Gene=="0.0"),]
    
    File_2<-File_2[complete.cases(File_2),]
    File_2<-File_2[!(File_2$Gene=="0.0"),]
    
    
    
    #Counts the number of collumns/patients in each file
    num_1 <- ncol(File_1)-1
    num_2 <- ncol(File_2)-1
    
    
    #Remove first column of Quartile that is being added
    #These are the counts that are will be merged to another
    new_file_1<- File_1[,-1]
    new_file_2<- File_2[,-1]
    
    
    #Create 'merged' Quartiles
    merged_files <- cbind(File_1,new_file_2)
    rownames(merged_files)=merged_files[,1]
    merged_files <- merged_files[,-1]
    
    print("before convert")
    #converts it to numeric
    merged_files <- data.frame(sapply(merged_files, as.numeric),check.names=F, row.names = rownames(merged_files))
    
    #Creates the matrices
    merged_files <- as.matrix(merged_files)
    
    print("after merge")
    #Assign Condition Q1 to all of the columns/samples/patients
    condition <- factor(c(rep(variable_condition_1, num_1),rep(variable_condition_2,num_2)))
    print("condition declaration")
    ####################################################################################
    #Create a coldata frame and instantiate the DESeqDataSet
    (col_data <- data.frame(row.names=colnames(merged_files),condition))
    print("can't reach col_data")
    dds <- DESeqDataSetFromMatrix(countData=merged_files, colData=col_data, design=~condition)
    print("declared col_data")
    ###################################################################################################################################
    
    dds = estimateSizeFactors(dds)
    
    #Run the DESeq pipeline, this takes a while
    dds <- DESeq(dds)
    
    print("run the pipeline")
    ###################################################################################################################################
    #Change the format into something that can be used by R (dds --> res)
    ###################################################################################################################################
    res <- results(dds)
    
    #Could be used if they want to reduce?
    #res <- lfcShrink(dds, coef=2, type="apeglm")
    
    #Orders the results via adjusted p-value
    res <- res[order(res$padj), ]
    # Merge with normalized count data
    resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
    names(resdata)[1] <- "Gene"
    head(resdata)
    pre_processed_file_full<-resdata
    ## Write results
    write.csv(resdata, file=paste("diffexpr_results",variable_condition_1,"vs",variable_condition_2,".csv"))
    
    print("after res, before plots")
    ## MA plot with with text
    ###################################################################################################################################
    #Sets up the function
    maplot_text <- function (res, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
        with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
        }
      },error=function(error_message){
      })
    }
    
    #Calls the function if the condition is met
    if (do_MA_plot==TRUE){
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png"), 7500, 7000, pointsize=15)
      suppressWarnings(maplot_text(resdata, main="MA Plot"))
      invisible(dev.off())
    }
    
    
    ## MA plot with no text
    ###################################################################################################################################
    #Sets up the function
    maplot_no_text <- function (res, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
        with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<thresh))#, textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
        }
      },error=function(error_message){
      })
    }
    
    #Calls the function is the condition is met
    if (do_MA_plot==TRUE){
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png"), 2500, 2000, pointsize=15)
      suppressWarnings(maplot_no_text(resdata, main="MA Plot"))
      invisible(dev.off())
    }
    
    
    print("after MA plots")
    ## Volcano plot with "significant" genes in green with text
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_text <- function (res, lfcthresh=1, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
        }
        legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","green"))
      },error=function(error_message){
      })
    }
    
    #Calls the function
    if(do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png"), 5200, 5000, pointsize=20)
      suppressWarnings(volcanoplot_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }
    
    
    ## Volcano plot with "significant" genes in green with no text active_reformed
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_no_text <- function (res, lfcthresh=2, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        x <-subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh)
        write.csv(x,file = paste(variable_condition_1,"vs",variable_condition_2,"_RESULTS_VOLCANO.csv",sep=""))
        return (x)
      },error=function(error_message){
      })
    }
    
    #Calls the function
    #this one is special, the function will be called regardless as it is used to produce the necessary list (X) which gives significant genes
    #However, depending on what the user wants, the function will only produce a list, or it will produce a list and create the corresponding volcano plot
    if (do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png"), 1200, 1000, pointsize=20)
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }else{
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
    }
    
    print("after Volcano plots")
    ###################################################################################################################################
    #Creates a file that is used to generate a list of the top 60 genes, 30 most up-regulated, and 30 most under-regulated
    
    file_for_sig_genes <-  pre_processed_file_short
    
    resUpReg= file_for_sig_genes[which(file_for_sig_genes$log2FoldChange<0),] #Get the upregulated genes
    resDownReg= file_for_sig_genes[which(file_for_sig_genes$log2FoldChange>0),]#Get the downregulated
    Upreg <- head(resUpReg[order(resUpReg$padj),],30) #order by P adjusted and print top 30*
    rownames(Upreg)=Upreg$Gene
    Downreg <- head(resDownReg[order(resDownReg$padj),],30)
    rownames(Downreg)=Downreg$Gene
    gene_list <- rownames(Upreg)
    gene_list <- append(gene_list,rownames(Downreg))
    write.table(gene_list,file=paste("gene_list_",variable_condition_1,"vs",variable_condition_2,"_Most_Significant.txt"))
    ###################################################################################################################################
    
    pre_processed_file_short <- pre_processed_file_short[,1:7]
    rownames(pre_processed_file_short) <- pre_processed_file_short[,1]
    pre_processed_file_short <- pre_processed_file_short[,-1]
    
    #Reached the end of the function without errors
    message<-paste("success, your file is located here:",getwd())
    print("i've reached the end")
  },
  error=function(error_message){
    outputFile <- "Error_and_Warning_Log.txt"
    writeLines(as.character(error_message), outputFile)
    message <- paste("Error, please check the 'Error_and_Warning_Log.txt' located here:",getwd())
    print("in error")
  }
  )
  print("before return")
  print(typeof(message))
  print(message)
  return (message)
}


#Variable set up for DESeq2 function
#############################################################################################################################################
# #The two files that will be read (Each are in the git-folder for convenience)
# File_1 <- read.csv(file = "C:\\Users\\yohan\\Desktop\\Analyse_Bioinformatique\\TCGA_GBM\\CSVs\\True_COUNTS_NORMAL_AGE_SUBSET_10_50_Formatted_CSV_VERSION.csv",check.names=FALSE)
# File_2 <-read.csv(file = "C:\\Users\\yohan\\Desktop\\Analyse_Bioinformatique\\TCGA_GBM\\CSVs\\True_COUNTS_NORMAL_AGE_SUBSET_69_89_Formatted_CSV_VERSION.csv",check.names=FALSE)
# #The conditions associated with the analysis, it could be control vs patient
# variable_condition_1 <- "young"
# variable_condition_2 <- "old"
# #Do they wan to generate MA plots and volcano plots?
# do_MA_plot <-TRUE
# do_Volcano_Plot <- TRUE
# #Directory set up, will it be usefull?
# #Directory Workplace!
# setwd("C:\\Users\\yohan\\Desktop")

#############################################################################################################################################


#DESeq2_file_short <- DESeq2_pre_processing(File_1, File_2, variable_condition_1, variable_condition_2, do_MA_plot, do_Volcano_Plot)





#The ui for the application
ui <- dashboardPage(skin="blue",
  dashboardHeader(title="INSERM 33"),
  dashboardSidebar(
    sidebarMenu(
      # Web site for the icons: https://fontawesome.com/icons?d=gallery&m=free
      menuItem("Information", tabName = "info", icon = icon("book-open")),
      menuItem("Connect to database", tabName = "connect_DB",icon= icon("database")),
      menuItem("Run analysis with DESeq2", tabName = "DESeq2_analysis", icon= icon("chart-bar")),
      menuItem("Results",tabName = "res", icon=icon("dna")),
      menuItem("Add gene to database", tabName = "add_DB", icon= icon("plus")),
      menuItem("Citation", tabName = "citation", icon= icon("book"))
    )
    
  ),
  #The main panel is set up to only contain a datatable of the dataset the user will enter, the height is limited as to ensure the table is adapted to low resolution screens
  
  dashboardBody(
    useShinyjs(),
    tabItems(
      tabItem(tabName = "info",
              h2("Information tab content")
      ),
      
      tabItem(tabName = "connect_DB",
              h2("Establish connection to the database"),
              textInput("email","Email Address:"),
              
              selectInput("study_type", "Type of Study",
                          choices = list("Metabolic" = "Metabolic",
                                         "Epigenetic" = "Epigenetic",
                                         "Metabolomic" = "Metabolomic",
                                         "Others" = "Others"),
                          selected = 1),
              
              selectInput("user_position", "Position held",
                          choices = list("Researcher" = "Researcher",
                                         "PhD" = "PhD",
                                         "Student" = "Student",
                                         "Intern" = "Intern",
                                         "Other" = "Other"),
                          selected = 1),
              
              textAreaInput("comments", "Comments", placeholder = "Feel free to add a comment",width="500px"),
              actionButton("connect_DB", "Connect to database"),
              textOutput("connect_db_status")
      ),
      
      tabItem(tabName = "DESeq2_analysis",
              h2("Run an analysis using DESeq2"),
              
              
              useShinyjs(),
              #Setting up the file input system of the application
              fileInput("file1", "Choose CSV File 1",
                        accept = c(
                          "text/csv",
                          "text/comma-separated-values,text/plain",
                          ".csv")
              ),
              fileInput("file2", "Choose CSV File 2",
                        accept = c(
                          "text/csv",
                          "text/comma-separated-values,text/plain",
                          ".csv")
              ),
              
              directoryInput('directory', label = 'select a directory', value = '~'),
              #Adds the text_input which will take in the first condition
              textInput("condition1", "Name of the condition for file 1", "Condition_1"),
              
              #Adds the text_input which will take in the first condition
              textInput("condition2", "Name of the condition for file 2", "Condition_2"),
              
              #A simple checkbox which will allow users to choose if they want to do MA plots
              checkboxInput("Make_MA", "Create MA Plots", value = TRUE, width = NULL),
              
              #A check box which will allow users to choose if they want to do Volcano plots
              checkboxInput("Make_Volcano", "Create Volcano Plots", value = TRUE, width = NULL),
              
              #The action button which will set the analysis in motion, it is initially disabled to prevent users form clicking the button while the requirements are not fufilled
              disabled(actionButton("launch", "Launch Analysis"))
      ),
      
      tabItem(tabName = "res",
              h2("Results tab")
      ),
      
      tabItem(tabName = "add_DB",
              h2("Add a gene to the non-canonical database")
      ),
      
      tabItem(tabName = "citation",
              h2("Information about citing the use of this tool")
      )
              
    ),
    DT::dataTableOutput("contents",width = 'auto',height = 500)
  )
)

#Handles the 'actions' that are done within the application
server <- function(input, output, session) {
  
  ############################################################################################################################################
  
  # #Should only appear if results have been given
  # #Won't be DESeq2_file_short, but a read csv from getwd() and file name using the variables and known build type
  # output$contents <- DT::renderDataTable({
  #   
  #   inFile1 <- DESeq2_file_short
  #   if (is.null(inFile1))
  #     return(NULL)
  #   m <- read.csv(inFile1$datapath, header = TRUE)
  #   DT::datatable(data=m, options=list(scrollX = TRUE,scrollY=TRUE,paging=FALSE),class = 'cell-border stripe', rownames = FALSE, fillContainer = TRUE)
  # })
  ############################################################################################################################################
  
  shinyjs::hide("contents")
  
  #Used to check if the email is valid when clicking the 'connect' button
  observeEvent(input$connect_DB, {(
    if (isValidEmail(input$email)==FALSE){
      output$connect_db_status <- renderText("Please enter a valid email address")
    }else if (nchar(input$comments)>300){
      output$connect_db_status <- renderText(paste("Too many characters in comment box. Characters used:",nchar(input$comments)))
      #Would add the action of the button here!
    }else{
      output$connect_db_status <- renderText(paste("Email address is valid. Characters in comment box:",nchar(input$comments)))
    }
  )})

  
  #This observe event handles the setting of the directory
  observeEvent(
    ignoreNULL = TRUE,
    eventExpr = {
      input$directory
    },
    handlerExpr = {
      if (input$directory > 0) {
        # condition prevents handler execution on initial app launch

        # launch the directory selection dialog with initial path read from the widget
        path = choose.dir(default = readDirectoryInput(session, 'directory'))
        # update the widget value
        updateDirectoryInput(session, 'directory', value = path)
        setwd(path)
      }
    }
  )
  
  #This creates a reactive variable which will be used as a verification for the enabling of the launch button
  #Using this, the application will prevent the user from starting an analysis without having entered a dataset
  check_if_upload_File1 <- reactiveValues(
    check_upload_File1=0
  )
  
  #Sets the check_if_upload variable to one if a file has been entered by the user
  observeEvent(input$file1, {(check_if_upload_File1$check_upload_File1 <- c(1))})
  
  #This creates a reactive variable which will be used as a verification for the enabling of the launch button
  #Using this, the application will prevent the user from starting an analysis without having entered a dataset
  check_if_upload_File2 <- reactiveValues(
    check_upload_File2=0
  )
  
  #Sets the check_if_upload variable to one if a file has been entered by the user
  observeEvent(input$file2, {(check_if_upload_File2$check_upload_File2 <- c(1))})
  
  #Enables the launch button when it all necessary prerequisites are met
  observe(if(check_if_upload_File1$check_upload_File1==1 && check_if_upload_File2$check_upload_File2==1&&
             input$condition1!=""&&input$condition2!=""){
    enable("launch")
  }else{
    disable("launch")
  })
  
  #The first action done when a user launches an analysis
  observeEvent(input$launch,{showModal(modalDialog("Working... you will be notified when the analysis is done"))})
  
  
  #Okay, so this one is complexe, this line of code does several things at once, and this was the only way I found to circumvent a certain error
  #This line starts by holding the message send by the launchMuma function, if the Launch function works well, it will return a string of characters, no issues here
  #If the launch function has an error in it's 'catch', the function returns itself as a variable of type 'closure', I was unable to prevent this
  #This means that the code can't simply show the message return as in some instances the message will not be of character type
  #So the second part of this line of code is to check the type of the 'message' that was returned, if it is of character type, all is well and it can be shown as it is,
  #If it is not of character type, it means there was an error, thus I manually add in the error message that should have been sent by the 'launchMuma' function.
  #This line of code could not be split as the stored 'message' is only present for the duration of this line of code.
  observeEvent(input$launch,{(message_from_function <-suppressWarnings(DESeq2_pre_processing(input$file1$datapath,input$file2$datapath, 
                                                                                             input$condition1,input$condition2,input$Make_MA,input$Make_Volcano)))
    (showModal(modalDialog(
      if (typeof(message_from_function)!="character"){
        paste("Error, please check the 'Error_and_Warning_Log.txt' located here:",getwd())
      }else{
        message_from_function
      })))
    
    if(typeof(message_from_function)=="character"){
      shinyjs::show("contents")
    }
    
  })
  
  
}


#The function that runs the entire application
shinyApp(ui=ui,server=server)#,options = list(port=6168))
#DESeq2_file_short <- DESeq2_pre_processing(File_1, File_2, variable_condition_1, variable_condition_2, do_MA_plot, do_Volcano_Plot)



