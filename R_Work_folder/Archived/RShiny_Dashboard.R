#This allows to modify function
#trace("explore.data",edit=TRUE)


if(!require(DESeq2)){
  install.packages("BiocManager")
  BiocManager::install("DESeq2")
  library( "DESeq2" )
  library(ggplot2)
  library(apeglm)
  library(DESeq2)
}

if(!require(ggplot2)){
  install.packages(ggplot2)
  library(ggplot2)
}

if(!require(shiny)){
  install.packages("shiny")
  library(shiny)
}

if(!require(shinyWidgets)){
  install.packages("shinyWidgets")
  library(shinyWidgets)
} 

if(!require("DT")){
  install.packages("DT")
  library(DT)
}

if(!require("shinyjs")){
  install.packages("shinyjs")
  library(shinyjs)
}

if(!require("shinyDirectoryInput")){
  devtools::install_github('wleepang/shiny-directory-input')
  library(shinyDirectoryInput)
}

if(!require("shinydashboard")){
  install.packages("shinydashboard")
  library(shinydashboard)
}

if(!require(RMySQL)){
  install.packages("RMySQL")
  library(RMySQL)
}

options(shiny.maxRequestSize = 100*1024^2)
#############################################################################################################################################

#A function that is called to remove empty plots that are generated by R.
#A common error/bug in R is that when files are automatically saved as pdf's, R opens up an Rplot.pdf to allocate the space for that pdf
#However if we do not use that pdf (which is our case), it remains present, empty, and open. After around 50 open pdf files, R crashes.
#This function was created to delete these files every so often to prevent an accumulation of emtpy Rplots, thus preventing crashes
remove_Rplots <- function (Directory)
{
  Files_to_Remove <- list.files(Directory, recursive = TRUE, all.files = TRUE, pattern="Rplots")
  for (i in Files_to_Remove){
    unlink(paste(Directory,"\\",i,sep=""))
  }
}

#Checks the validity of an entered e-mail
isValidEmail <- function(x) 
{
  grepl("\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\>", as.character(x), 
        ignore.case=TRUE)
}

#Create the function for Deseq2
DESeq2_pre_processing <- function(File_1, File_2, variable_condition_1, variable_condition_2, do_MA_plot, do_Volcano_Plot)
{
  
  #Everything is in a try catch to ensure that the application does not crash in the event of an error
  #If an error does occur, it was desired that the application prints the error in a txt file and tells the user that an error has occured
  tryCatch({
    
    ###################################################################################################################################
    #File preperations for a file merge, i.e obtaining the necessary format for DESeq2 preprocessing
    ###################################################################################################################################
    File_1 <- read.csv(file = File_1,check.names=FALSE)
    File_2 <-read.csv(file = File_2,check.names=FALSE)
    
    #Filters out 0's and NA's, if a file is properly prepared, none of these should occur
    File_1<-File_1[complete.cases(File_1),]
    File_1<-File_1[!(File_1$Gene=="0.0"),]
    
    File_2<-File_2[complete.cases(File_2),]
    File_2<-File_2[!(File_2$Gene=="0.0"),]
    
    
    
    #Counts the number of collumns/patients in each file
    num_1 <- ncol(File_1)-1
    num_2 <- ncol(File_2)-1
    
    
    #Remove first column of Quartile that is being added
    #These are the counts that are will be merged to another
    new_file_1<- File_1[,-1]
    new_file_2<- File_2[,-1]
    
    
    #Create 'merged' Quartiles
    merged_files <- cbind(File_1,new_file_2)
    rownames(merged_files)=merged_files[,1]
    merged_files <- merged_files[,-1]
    
    #converts it to numeric
    merged_files <- data.frame(sapply(merged_files, as.numeric),check.names=F, row.names = rownames(merged_files))
    
    #Creates the matrices
    merged_files <- as.matrix(merged_files)
    
    #Assign Condition Q1 to all of the columns/samples/patients
    condition <- factor(c(rep(variable_condition_1, num_1),rep(variable_condition_2,num_2)))
    ####################################################################################
    #Create a coldata frame and instantiate the DESeqDataSet
    (col_data <- data.frame(row.names=colnames(merged_files),condition))
    dds <- DESeqDataSetFromMatrix(countData=merged_files, colData=col_data, design=~condition)
    ###################################################################################################################################
    
    dds = estimateSizeFactors(dds)
    
    #Run the DESeq pipeline, this takes a while
    dds <- DESeq(dds)
    
    ###################################################################################################################################
    #Change the format into something that can be used by R (dds --> res)
    ###################################################################################################################################
    res <- results(dds)
    
    #Could be used if they want to reduce?
    #res <- lfcShrink(dds, coef=2, type="apeglm")
    
    #Orders the results via adjusted p-value
    res <- res[order(res$padj), ]
    # Merge with normalized count data
    resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
    names(resdata)[1] <- "Gene"
    head(resdata)
    pre_processed_file_full<-resdata
    ## Write results
    write.csv(resdata, file=paste("diffexpr_results",variable_condition_1,"vs",variable_condition_2,".csv"))
    
    ## MA plots
    ###################################################################################################################################
    #Sets up the function
    maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
        with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
        }
      },error=function(error_message){
      })
    }
    
    #Calls the function if the condition is met
    if (do_MA_plot==TRUE){
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png"), 7500, 7000, pointsize=15)
      suppressWarnings(maplot(resdata, main="MA Plot"))
      invisible(dev.off())
      #With text
      png(paste("diffexpr_maplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png"), 2500, 2000, pointsize=15)
      suppressWarnings(maplot(resdata, main="MA Plot",labelsig = FALSE))
      invisible(dev.off())
    }

    
    ## Volcano plot with "significant" genes in green with text
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_text <- function (res, lfcthresh=1, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        if (labelsig) {
          require(calibrate)
          with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
        }
        legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","green"))
      },error=function(error_message){
      })
    }
    
    #Calls the function
    if(do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_Text.png"), 5200, 5000, pointsize=20)
      suppressWarnings(volcanoplot_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }
    
    
    ## Volcano plot with "significant" genes in green with no text active_reformed
    ###################################################################################################################################
    #Sets up the function
    volcanoplot_no_text <- function (res, lfcthresh=2, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
      tryCatch({
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
        x <-subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh)
        write.csv(x,file = paste(variable_condition_1,"vs",variable_condition_2,"_RESULTS_VOLCANO.csv",sep=""))
        return (x)
      },error=function(error_message){
      })
    }
    
    #Calls the function
    #this one is special, the function will be called regardless as it is used to produce the necessary list (X) which gives significant genes
    #However, depending on what the user wants, the function will only produce a list, or it will produce a list and create the corresponding volcano plot
    if (do_Volcano_Plot==TRUE){
      png(paste("diffexpr_volcanoplot_",variable_condition_1,"vs",variable_condition_2,"_No_Text.png"), 1200, 1000, pointsize=20)
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
      invisible(dev.off())
    }else{
      pre_processed_file_short<-suppressWarnings(volcanoplot_no_text(resdata, lfcthresh=1, sigthresh=0.05, textcx=.8, xlim=c(-5, 5)))
    }
    
    ###################################################################################################################################
    #Creates a file that is used to generate a list of the top 60 genes, 30 most up-regulated, and 30 most under-regulated
    
    file_for_sig_genes <-  pre_processed_file_short
    
    resUpReg= file_for_sig_genes[which(file_for_sig_genes$log2FoldChange<0),] #Get the upregulated genes
    resDownReg= file_for_sig_genes[which(file_for_sig_genes$log2FoldChange>0),]#Get the downregulated
    Upreg <- head(resUpReg[order(resUpReg$padj),],30) #order by P adjusted and print top 30*
    rownames(Upreg)=Upreg$Gene
    Downreg <- head(resDownReg[order(resDownReg$padj),],30)
    rownames(Downreg)=Downreg$Gene
    gene_list <- rownames(Upreg)
    gene_list <- append(gene_list,rownames(Downreg))
    write.table(gene_list,file=paste("gene_list_",variable_condition_1,"vs",variable_condition_2,"_Most_Significant.txt"))
    ###################################################################################################################################
    
    pre_processed_file_short <- pre_processed_file_short[,1:7]
    # rownames(pre_processed_file_short) <- pre_processed_file_short[,1]
    # pre_processed_file_short <- pre_processed_file_short[,-1]
    
    #Reached the end of the function without errors
    return_message<-paste("success, your file is located here:",getwd())
  },
  error=function(error_message){
    outputFile <- "Error_and_Warning_Log.txt"
    writeLines(as.character(error_message), outputFile)
    return_message <- paste("Error, please check the 'Error_and_Warning_Log.txt' located here:",getwd())
  }
  )

  return_list <- list("message"=return_message,"file"=pre_processed_file_short)
  return (return_list)
}

#Connects to the database once the user has filled in the form
Connect_to_database <- function()
{
  DB <- dbConnect(RMySQL::MySQL(), user="root", host="localhost",
                  password="UpsilonLambda94", dbname="non_canonic")
  return(DB)
}

#Uses the database connection to check for non_canonical genes
Non_canonic_analysis <- function(DB,file_to_analyze)
{
  sig_gene_list<-rownames(file_to_analyze)

  #Initialize dataframes
  non_canonic_results <- data.frame(
    Gene_Symbol=character(),
    NC_Pathway=character(), 
    NC_Loc=character(), 
    num_ncan=integer(),
    stringsAsFactors=FALSE)
  
  canonic_results <- data.frame(
    Gene_Symbol=character(),
    Gene_Name = character(),
    NC_Pathway=character(), 
    NC_Loc=character(), 
    num_ncan=integer(),
    stringsAsFactors=FALSE) 
  
  ref_results <- data.frame(
    Gene_Symbol=character(),
    ref = character(),
    stringsAsFactors=FALSE) 
  
  
  for (i in 1:length(sig_gene_list)){
    if (nrow(dbGetQuery(DB, paste0("SELECT * FROM Canonic WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))>0){
      non_canonic_results <- rbind(non_canonic_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, NC_Pathway as Non_Canonic_Pathway, NC_Loc as Non_Canonic_Location FROM ncanonic join canonic using (Gene_Symbol) WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
      canonic_results <- rbind(canonic_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, C_Pathway as Canonical_Pathway, C_Loc as Canonical_Location FROM Canonic WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
      ref_results <- rbind(ref_results,dbGetQuery(DB, paste0("SELECT Gene_Symbol, Gene_Name, ref as `References` FROM `references` join Canonic using (Gene_Symbol) WHERE Gene_Symbol = '" , sig_gene_list[i]  ,"';")))
    }
    
  }
  
  #Store each dataframe in a list for return
  
  my_results_list <- list("sig_genes"=file_to_analyze,"ncan"=non_canonic_results,"can"=canonic_results,"refs"=ref_results)
  
  write.table(my_results_list[["ncan"]],file = "non_canonic_results.txt",row.names = FALSE)
  
  write.table(my_results_list[["can"]],file = "canonic_results.txt",row.names = FALSE)
  
  write.table(my_results_list[["refs"]],file = "references.txt",row.names = FALSE)
  
  
  
  dbDisconnect(DB)
  
  return(my_results_list)
}

custom_MA_plot <- function (fig_file, sig_pval=0.05, labelsig=FALSE, textcx=1, ...) 
{
    file_to_plot <-read.csv(file = fig_file,check.names=FALSE)

    with(file_to_plot, plot(baseMean, log2FoldChange, col="black", pch=20, cex=.5, log="x", ...))
    with(subset(file_to_plot, padj<sig_pval), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
    if (labelsig) {
      require(calibrate)
      with(subset(file_to_plot, padj<sig_pval), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
    }

}

custom_Volcano_plot <- function (fig_file, lfcthresh=1, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=FALSE, textcx=1, ...) 
{

  file_to_plot <-read.csv(file = fig_file,check.names=FALSE)
  
  with(file_to_plot, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
  with(subset(file_to_plot, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
  with(subset(file_to_plot, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
  with(subset(file_to_plot, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
  if (labelsig) {
    require(calibrate)
    with(subset(file_to_plot, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
  }
  legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","green"))

}


#############################################################################################################################################



#The ui for the application
ui <- dashboardPage(skin="blue",
  dashboardHeader(title="INSERM 33"),
  dashboardSidebar(
    sidebarMenu(
      useShinyjs(),
      # Web site for the icons: https://fontawesome.com/icons?d=gallery&m=free
      menuItem("Information", tabName = "info", icon = icon("book-open")),
      menuItem("Connect to database", tabName = "connect_DB",icon= icon("database")),
      menuItem("Run analysis with DESeq2", tabName = "DESeq2_analysis", icon= icon("chart-bar")),
      menuItem("Results",tabName = "res", icon=icon("dna")),
      menuItem("Custom MA plots",tabName = "cus_MA", icon=icon("file-image")),
      menuItem("Custom Volcano plots",tabName = "cus_Volcano", icon=icon("file-image")),
      menuItem("Citation", tabName = "citation", icon= icon("book")),
      
      #Sets up the code for the close button
      extendShinyjs(text = "shinyjs.closeWindow = function() { window.close(); }", functions = c("closeWindow")),
      
      #Use of a flui row to set the button at the bottom
      #Issue is that it is set there using pixel margins, so it will have to be manually adjusted when adding tabs
      fluidRow(
        column(6,style="margin-top: 500px;",actionButton("close", "Exit App"))
      )
      
    )
    
  ),
  #The main panel is set up to only contain a datatable of the dataset the user will enter, the height is limited as to ensure the table is adapted to low resolution screens
  
  dashboardBody(
    useShinyjs(),
    tabItems(
      tabItem(tabName = "info",
              h2("Information tab content")
      ),
      
      tabItem(tabName = "connect_DB",
              h2("Establish connection to the database"),
              textInput("email","Email Address:"),
              
              selectInput("study_type", "Type of Study",
                          choices = list("Metabolic" = "Metabolic",
                                         "Epigenetic" = "Epigenetic",
                                         "Metabolomic" = "Metabolomic",
                                         "Others" = "Others"),
                          selected = 1),
              
              selectInput("user_position", "Position held",
                          choices = list("Researcher" = "Researcher",
                                         "PhD" = "PhD",
                                         "Student" = "Student",
                                         "Intern" = "Intern",
                                         "Other" = "Other"),
                          selected = 1),
              
              textAreaInput("comments", "Comments", placeholder = "Feel free to add a comment",width="500px"),
              actionButton("connect_DB", "Connect to database"),
              textOutput("connect_db_status")
      ),
      
      tabItem(tabName = "DESeq2_analysis",
              h2("Run an analysis using DESeq2"),
              
              
              useShinyjs(),
              #Setting up the file input system of the application
              fileInput("file1", "Choose CSV File 1",
                        accept = c(
                          "text/csv",
                          "text/comma-separated-values,text/plain",
                          ".csv")
              ),
              fileInput("file2", "Choose CSV File 2",
                        accept = c(
                          "text/csv",
                          "text/comma-separated-values,text/plain",
                          ".csv")
              ),
              
              directoryInput('directory', label = 'select a directory', value = '~'),
              #Adds the text_input which will take in the first condition
              textInput("condition1", "Name of the condition for file 1", "Condition_1"),
              
              #Adds the text_input which will take in the first condition
              textInput("condition2", "Name of the condition for file 2", "Condition_2"),
              
              #A simple checkbox which will allow users to choose if they want to do MA plots
              checkboxInput("Make_MA", "Create standard MA Plots", value = TRUE, width = NULL),
              
              #A check box which will allow users to choose if they want to do Volcano plots
              checkboxInput("Make_Volcano", "Create standard Volcano Plots", value = TRUE, width = NULL),
              
              #The action button which will set the analysis in motion, it is initially disabled to prevent users form clicking the button while the requirements are not fufilled
              disabled(actionButton("launch", "Launch Analysis")),
              textOutput("launch_status")
      ),
      
      tabItem(tabName = "res",
              h2("Results tab"),
              textOutput("results_status"),
              
              tabsetPanel(id="results_tabs",type="tabs",
                tabPanel("Significant Genes", DT::dataTableOutput("sig_genes",width = 'auto',height = 500)),
                tabPanel("Non_Canonic", DT::dataTableOutput("Ncan",width = 'auto',height = 500)),
                tabPanel("Canonic", DT::dataTableOutput("Can",width = 'auto',height = 500)),
                tabPanel("References", DT::dataTableOutput("refs",width = 'auto',height = 500))
              )
      ),
      
      tabItem(tabName = "cus_MA",
              h2("Generate custom MA plots"),
              fluidRow(
                column(4,
                       fileInput("file_custom_MA", "Choose CSV File",
                        accept = c(
                          "text/csv",
                          "text/comma-separated-values,text/plain",
                          ".csv")
                       )
                ),
                column(4,offset=2,
                       downloadButton('download_MA_Plot', 'Download Plot'),
                       downloadButton('download_MA_data','Download Data')
                       )
              ),

              fluidRow(
                column(3,
                       numericInput("p_value_thresh_MA", label = "P-value significance", value = 0.05,min = 0.0,max = 1,step = 0.01),
                ),
                column(3,
                       textInput("title_of_MA_plot","Title of the plot","my_MA_plot")
                ),  
                
                column(3,
                       tags$b("Add text to red genes"),
                       checkboxInput("text_choice_MA","Render text", value=FALSE, width = NULL)
                ),
                column(3,
                       tags$b("Create the plot"),
                       actionButton("create_MA","create_MA")
                )
              ),
              plotOutput("custom_MA_plot")
              
              
      ),
      tabItem(tabName = "cus_Volcano",
              h2("Generate custom Volcano plots"),
              fluidRow(
                column(4,
                       fileInput("file_custom_Volcano", "Choose CSV File",
                                 accept = c(
                                   "text/csv",
                                   "text/comma-separated-values,text/plain",
                                   ".csv")
                       )
                ),
                column(2, offset=2,
                       downloadButton('download_Volcano_Plot', 'Download Plot'),
                       #br()/break is not working
                       br(),
                       downloadButton('download_Volcano_Data', 'Download Data')
                )
                # column(3,style="margin-top: 25px;",offset=1,
                #        downloadButton('download_Volcano_Data', 'Download Data')
                # )
              ),
              
              fluidRow(
                column(3,
                       numericInput("p_value_thresh_Volcano", label = "P-value significance", value = 0.05,min = 0.0,max = 1,step = 0.01),
                ),
                column(3,
                       textInput("title_of_Volcano_plot","Title of the plot","my_Volcano_plot")
                ),  
                
                column(3,
                       tags$b("Add text to red genes"),
                       checkboxInput("text_choice_Volcano","Render text", value=FALSE, width = NULL)
                ),
                column(3,
                       tags$b("Create the plot"),
                       actionButton("create_Volcano","create_Volcano")
                ),
              ),
              fluidRow(
                column(4,offset=1,
                       numericInput("lfc_value_thresh", label = "LFC threshold", value = 1,min = 0.0,max = 5,step = 0.5),
                ),
                column(4,offset=1,
                       selectInput("legend_position", "Position of legend on graph",
                                   choices = list("bottomleft" = "bottomleft",
                                                  "bottom" = "bottom",
                                                  "bottomright" = "bottomright",
                                                  "left" = "left",
                                                  "center" = "center",
                                                  "right" = "right",
                                                  "topleft" = "topleft",
                                                  "top" = "top",
                                                  "topright"="topright"),
                                   
                                   selected = 1),
                )
              ),
              plotOutput("custom_Volcano_plot")
      ),
      tabItem(tabName = "citation",
              h2("How to cite this tool")
      )
      
    ),
    
    #DT::dataTableOutput("contents",width = 'auto',height = 500)
  )
)

#Handles the 'actions' that are done within the application
server <- function(input, output, session) {
  
  #Hides the results table as they will be empty/non-existant
  hideTab(inputId = "results_tabs", target = "Significant Genes")
  hideTab(inputId = "results_tabs", target = "Non_Canonic")
  hideTab(inputId = "results_tabs", target = "Canonic")
  hideTab(inputId = "results_tabs", target = "References")
  
  #Create a function
  #The function is declared here as it contains server specific objects (output), thus it can only be declared within the server
  show_results <- function(List_of_results)
  {
    
    output$sig_genes <- DT::renderDataTable({
      DT::datatable(data=List_of_results[["sig_genes"]], options=list(scrollX = TRUE,scrollY=TRUE,paging=FALSE),class = 'cell-border stripe', rownames = FALSE, fillContainer = TRUE)
    })
    output$Ncan <- DT::renderDataTable({
      DT::datatable(data=List_of_results[["ncan"]], options=list(scrollX = TRUE,scrollY=TRUE,paging=FALSE),class = 'cell-border stripe', rownames = FALSE, fillContainer = TRUE)
    })
    output$Can <- DT::renderDataTable({
      DT::datatable(data=List_of_results[["can"]], options=list(scrollX = TRUE,scrollY=TRUE,paging=FALSE),class = 'cell-border stripe', rownames = FALSE, fillContainer = TRUE)
    })
    output$refs <- DT::renderDataTable({
      DT::datatable(data=List_of_results[["refs"]], options=list(scrollX = TRUE,scrollY=TRUE,paging=FALSE),class = 'cell-border stripe', rownames = FALSE, fillContainer = TRUE)
    })
  }
  
  observeEvent(input$close, 
  {
    js$closeWindow()
    stopApp()
  })
  
 
  
  
  #Create the MA plot
  observeEvent(input$create_MA,{output$custom_MA_plot <-renderPlot({isolate({custom_MA_plot(input$file_custom_MA$datapath, 
                                                                                           sig_pval = input$p_value_thresh_MA, 
                                                                                           main=input$title_of_MA_plot,
                                                                                           labelsig = input$text_choice_MA)})})
  })
  
  #Download the MA plot
  output$download_MA_Plot <- downloadHandler(
    filename = function(){
      paste(input$title_of_MA_plot,".png",sep="")
    },
    content = function(file){
      if (input$text_choice_MA==FALSE){
        png(file,width=1200, height=1000, pointsize=20)
      }else{
        png(file,width=5200, height=5000, pointsize=20)
      }
      
      isolate({custom_MA_plot(input$file_custom_MA$datapath, 
                              sig_pval = input$p_value_thresh_MA, 
                              main=input$title_of_MA_plot,
                              labelsig = input$text_choice_MA)})
      dev.off()
    }
  )
  
  
  
  #Download the MA plot data
  output$download_MA_data <- downloadHandler(
    filename = function(){
      paste(input$title_of_MA_plot,".csv",sep="")
    },
    content = function(file){
      x <-read.csv(file = input$file_custom_MA$datapath,check.names=FALSE)
      x <-subset(x, padj<input$p_value_thresh_MA)
      #Remove an unecessary row
      x<-x[,-1]
      write.csv(x,file)
    }
  )
  
  
  
  #Create the volcano plot
  observeEvent(input$create_Volcano,{output$custom_Volcano_plot <-renderPlot({isolate({custom_Volcano_plot(input$file_custom_Volcano$datapath, 
                                                                                            lfcthresh = input$lfc_value_thresh,
                                                                                            sigthresh = input$p_value_thresh_Volcano,
                                                                                            main=input$title_of_Volcano_plot,
                                                                                            legendpos=input$legend_position,
                                                                                            labelsig = input$text_choice_MA)})})
  })
  
  
  
  
  #Download the Volcano plot
  output$download_Volcano_Plot <- downloadHandler(
    filename = function(){
      paste(input$title_of_Volcano_plot,".png",sep="")
    },
    content = function(file){

      if (input$text_choice_Volcano==FALSE){
        png(file,width=1200, height=1000, pointsize=20)
      }else{
        png(file,width=5200, height=5000, pointsize=20)
      }
      
      isolate({custom_Volcano_plot(input$file_custom_Volcano$datapath, 
                                   lfcthresh = input$lfc_value_thresh,
                                   sigthresh = input$p_value_thresh_Volcano,
                                   main=input$title_of_Volcano_plot,
                                   legendpos=input$legend_position,
                                   labelsig = input$text_choice_MA)})
      dev.off()
    }
  )
  
  #Download the Volcano plot data
  output$download_Volcano_Data <- downloadHandler(
    filename = function(){
      paste(input$title_of_Volcano_plot,".csv",sep="")
    },
    content = function(file){
      x <-read.csv(file = input$file_custom_Volcano$datapath,check.names=FALSE)
      x <-subset(x, padj<input$p_value_thresh_Volcano & abs(log2FoldChange)>input$lfc_value_thresh)
      #Remove an unecessary row
      x<-x[,-1]
      write.csv(x,file)
    }
  )


  #This creates a reactive variable
  DB_Connect <- reactiveValues(
    DB=NULL
  )
  
  #Used to check if the email is valid when clicking the 'connect' button
  observeEvent(input$connect_DB, {(
    if (isValidEmail(input$email)==FALSE){
      output$connect_db_status <- renderText("Please enter a valid email address")
    }else if (nchar(input$comments)>300){
      output$connect_db_status <- renderText(paste("Too many characters in comment box. Characters used:",nchar(input$comments)))
    }else{
      output$connect_db_status <- renderText(paste("Email address is valid. Characters in comment box:",nchar(input$comments)))
      #Change the value of the reactive variable
      DB_Connect$DB<-Connect_to_database()
    }
  )})

  
  #This observe event handles the setting of the directory
  observeEvent(
    ignoreNULL = TRUE,
    eventExpr = {
      input$directory
    },
    handlerExpr = {
      if (input$directory > 0) {
        # condition prevents handler execution on initial app launch

        # launch the directory selection dialog with initial path read from the widget
        path = choose.dir(default = readDirectoryInput(session, 'directory'))
        # update the widget value
        updateDirectoryInput(session, 'directory', value = path)
        setwd(path)
      }
    }
  )
  
  #This creates a reactive variable which will be used as a verification for the enabling of the launch button
  #Using this, the application will prevent the user from starting an analysis without having entered a dataset
  check_if_upload_File1 <- reactiveValues(
    check_upload_File1=0
  )
  
  #Sets the check_if_upload variable to one if a file has been entered by the user
  observeEvent(input$file1, {(check_if_upload_File1$check_upload_File1 <- c(1))})
  
  #This creates a reactive variable which will be used as a verification for the enabling of the launch button
  #Using this, the application will prevent the user from starting an analysis without having entered a dataset
  check_if_upload_File2 <- reactiveValues(
    check_upload_File2=0
  )
  
  #Sets the check_if_upload variable to one if a file has been entered by the user
  observeEvent(input$file2, {(check_if_upload_File2$check_upload_File2 <- c(1))})
  
  #Enables the launch button when it all necessary prerequisites are met
  observe(if(check_if_upload_File1$check_upload_File1==1 && check_if_upload_File2$check_upload_File2==1&&
             input$condition1!=""&&input$condition2!="" && is.null(DB_Connect$DB)==FALSE){
    enable("launch")
    output$launch_status <- renderText("")
  }else{
    disable("launch")
    if(is.null(DB_Connect$DB)==TRUE){
      output$launch_status <- renderText("You are not yet connected to the data base")
    }else{
      output$launch_status <- renderText("Connected to database")
    }
  })
  
  
  #The first action done when a user launches an analysis
  observeEvent(input$launch,{showModal(modalDialog("Working... you will be notified when the analysis is done"))})
  
  
  #Okay, so this one is complexe, this line of code does several things at once, and this was the only way I found to circumvent a certain error
  #This line starts by holding the message send by the launchMuma function, if the Launch function works well, it will return a string of characters, no issues here
  #If the launch function has an error in it's 'catch', the function returns itself as a variable of type 'closure', I was unable to prevent this
  #This means that the code can't simply show the message return as in some instances the message will not be of character type
  #So the second part of this line of code is to check the type of the 'message' that was returned, if it is of character type, all is well and it can be shown as it is,
  #If it is not of character type, it means there was an error, thus I manually add in the error message that should have been sent by the 'launchMuma' function.
  #This line of code could not be split as the stored 'message' is only present for the duration of this line of code.
  observeEvent(input$launch,{(my_list <-suppressWarnings(DESeq2_pre_processing(input$file1$datapath,input$file2$datapath, 
                                                                                             input$condition1,input$condition2,input$Make_MA,input$Make_Volcano)))
    

    (showModal(modalDialog(
      if (typeof(my_list[["message"]])!="character"){
        paste("Error, please check the 'Error_and_Warning_Log.txt' located here:",getwd())
      }else{
        my_list[["message"]]
        
      })))
    
    if(typeof(my_list[["message"]])=="character"){
      #shinyjs::show("contents")
    }
    

    Final_Results <- Non_canonic_analysis(DB_Connect$DB,my_list[["file"]])
    #Below is the format of 'Final_Results'
    #list("sig_genes"=file_to_analyze,"ncan"=non_canonic_results,"can"=canonic_results,"refs"=ref_results)
    
    
    #Call a function to print the results
    show_results(Final_Results)
    showTab(inputId = "results_tabs", target = "Significant Genes")
    showTab(inputId = "results_tabs", target = "Non_Canonic")
    showTab(inputId = "results_tabs", target = "Canonic")
    showTab(inputId = "results_tabs", target = "References") 

  })
  
}


#The function that runs the entire application
shinyApp(ui=ui,server=server)#,options = list(port=6168))



